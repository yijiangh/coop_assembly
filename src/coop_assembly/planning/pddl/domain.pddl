(define (domain construction)
  (:requirements :strips :equality)
  (:predicates
    (Robot ?r)
    (Element ?e)
    (Printed ?e)
    (Removed ?e)
    (PrintAction ?r ?e ?q1 ?q2 ?t)
    (MoveAction ?r ?q ?t)
    (Grounded ?e)
    (Connected ?e)
    (Joined ?e1 ?e2)
    ; (Stiff)
    (Traj ?r ?t)
    (Collision ?t ?e)
    ; (Order ?e1 ?e2)
    (CanMove ?r)
    (Conf ?r ?q)
    (AtConf ?r ?q)
    (AtStart ?q ?t)
    (Assigned ?r ?e)
  )

;   (:action move
;     ; :parameters (?r ?q1 ?q2 ?t)
;     :parameters (?r ?q2 ?t2)
;     :precondition (and ; (Conf ?r ?q1)
;                     ;    (AtConf ?r ?q1)
;                        (Conf ?r ?q2)
;                        (Traj ?r ?t2)
;                        (CanMove ?r)
;                        (MoveAction ?r ?q2 ?t2)
;                        (forall (?e2) (imply (Collision ?t2 ?e2) (Removed ?e2)))
;                        )
;     :effect (and ;(not (AtConf ?r ?q1))
;                  (AtConf ?r ?q2)
;                  (not (CanMove ?r)) ; switch to avoid transit forever
;                  )
;   )

  ; print = remove the element
  (:action print
    :parameters (?r ?e ?q1 ?q2 ?t)
    :precondition (and (PrintAction ?r ?e ?q1 ?q2 ?t)
                       (Printed ?e)
                       ; (Stiff)
                    ;    (Connected ?e)
                       (forall (?e2) (imply (Collision ?t ?e2) (Removed ?e2)))
                       ;;; comment the following two if no transit
                    ;    (AtConf ?r ?q1) ; this will force a move action
                    ;    (not (CanMove ?r))
                       )
    :effect (and (Removed ?e)
                 (not (Printed ?e))
                ;  (CanMove ?r)
                 )
  )

;   (:derived (Connected ?e2)
;    (or (Grounded ?e2)
;        (exists (?e1) (and (Joined ?e1 ?e2)
;                           (Printed ?e1)
;                           (Connected ?e1)
;                      )
;        )
;    )
;   )
)
