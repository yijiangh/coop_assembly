(define (domain construction)
  (:requirements :strips :equality)
  (:predicates
    (Robot ?r)
    (Element ?e)
    (Assembled ?e)
    (Removed ?e)
    (PlaceAction ?r ?e ?q1 ?q2 ?t)
    (MoveAction ?r ?q2 ?t)
    (Grounded ?e)
    (Connected ?e)
    (Joined ?e1 ?e2)
    (Traj ?r ?t)
    (CollisionFree ?t ?e)
    (SafeTraj ?t)
    (CanMove ?r)
    (Conf ?r ?q)
    (AtConf ?r ?q)
    (AtStart ?q ?t)
    (Assigned ?r ?e)
    ; (Stiff)
    ; (Order ?e1 ?e2)
  )

  (:action move
    ; :parameters (?r ?q1 ?q2 ?t2)
    :parameters (?r ?q2 ?t2)
    :precondition (and
                        ; (Conf ?r ?q1)
                        ; (AtConf ?r ?q1)
                        (Conf ?r ?q2)
                        (Traj ?r ?t2)
                        (CanMove ?r)
                        (MoveAction ?r ?q2 ?t2)
                        ; (forall (?e2) (imply (Collision ?t2 ?e2) (Removed ?e2)))
                        (SafeTraj ?t2)
                       )
    :effect (and
                ;  (not (AtConf ?r ?q1))
                 (AtConf ?r ?q2)
                 (not (CanMove ?r)) ; switch to avoid transit forever
                 )
  )

  ; place = remove the element
  (:action place
    :parameters (?r ?e ?q1 ?q2 ?t)
    :precondition (and (PlaceAction ?r ?e ?q1 ?q2 ?t)
                       (Assembled ?e)
                       ; (Stiff)
                       (Connected ?e)
                    ;    (forall (?e2) (imply (Collision ?t ?e2) (Removed ?e2)))
                       (SafeTraj ?t)
                       ;;; comment the following two if no transit
                    ;    (AtConf ?r ?q1) ; this will force a move action
                    ;    (not (CanMove ?r))
                       )
    :effect (and (Removed ?e)
                 (CanMove ?r)
                 (not (Assembled ?e))
                 (not (AtConf ?r ?q1))
                ;  (AtConf ?r ?q2)
                 )
  )

  (:derived (Connected ?e2)
   (or (Grounded ?e2)
       (exists (?e1) (and (Joined ?e1 ?e2)
                          (Assembled ?e1)
                          (Connected ?e1)
                     )
       )
   )
  )

  (:derived (SafeTraj ?t)
   (forall (?e2) (imply (Assembled ?e2)
                        (CollisionFree ?t ?e2)
                  ))
  )

;   (:derived (UnsafeTraj ?t)
;    (exists (?e2) (and (Assembled ?e2)
;                       (Collision ?t ?e2)
;                   )
;    )
)
