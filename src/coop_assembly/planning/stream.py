import numpy as np
import random

from collections import namedtuple

# from extrusion.utils import get_disabled_collisions, get_custom_limits, MotionTrajectory

from pybullet_planning import get_movable_joints, link_from_name, set_pose, \
    multiply, invert, inverse_kinematics, plan_direct_joint_motion, Attachment, set_joint_positions, plan_joint_motion, \
    get_configuration, wait_for_interrupt, point_from_pose, HideOutput, load_pybullet, draw_pose, unit_quat, create_obj, \
    add_body_name, get_pose, pose_from_tform, connect, WorldSaver, get_sample_fn, \
    wait_for_duration, enable_gravity, enable_real_time, trajectory_controller, simulate_controller, \
    add_fixed_constraint, remove_fixed_constraint, Pose, Euler, get_collision_fn, LockRenderer, user_input, has_gui, \
    disconnect

##################################################

""" simple container for an element
"""
Brick = namedtuple('Brick', ['index', 'body', 'initial_pose', 'goal_pose',
                             'grasps', 'goal_supports'])

class WorldPose(object):
    def __init__(self, index, value):
        self.index = index
        self.value = value
    def __repr__(self):
        return '{}({},{})'.format(self.__class__.__name__, self.index,
                                  str(np.array(point_from_pose(self.value))))

class Grasp(object):
    def __init__(self, index, num, approach, attach, retreat):
        self.index = index # bar vertex key
        self.num = num # grasp id associated for a bar
        self.approach = approach
        self.attach = attach
        self.retreat = retreat
    def __repr__(self):
        return '{}({},{})'.format(self.__class__.__name__, self.index, self.num)

def get_grasp_gen_fn(brick_from_index):
    """[summary]

    Parameters
    ----------
    brick_from_index : dict
        {brick id : pb body}
    """
    def gen_fn(index):
        brick = brick_from_index[index]
        while True:
            # TODO: sliding along the bar's axis
            original_grasp = random.choice(brick.grasps)
            theta = random.uniform(-np.pi, +np.pi)
            rotation = Pose(euler=Euler(yaw=theta))
            new_attach = multiply(rotation, original_grasp.attach)
            grasp = Grasp(None, None, None, new_attach, None)
            yield grasp,
    return gen_fn

# the initial pose is fixed, the goal poses can be generated by rotational symmetry
# so the total grasp posibility is generated by:
# rotational goal pose x grasp sliding

# the approach pose is independent of grasp and symmetry, can be generated independently

def get_ik_gen_fn(robot, brick_from_index, obstacle_from_name, max_attempts=25):
    movable_joints = get_movable_joints(robot)
    tool_link = link_from_name(robot, TOOL_NAME)
    disabled_collisions = get_disabled_collisions(robot)
    sample_fn = get_sample_fn(robot, movable_joints)
    approach_distance = 0.1
    #approach_distance = 0.0
    approach_vector = approach_distance*np.array([0, 0, -1])

    def gen_fn(index, pose, grasp):
        body = brick_from_index[index].body
        set_pose(body, pose.value)

        obstacles = list(obstacle_from_name.values()) # + [body]
        collision_fn = get_collision_fn(robot, movable_joints, obstacles=obstacles, attachments=[],
                                        self_collisions=SELF_COLLISIONS,
                                        disabled_collisions=disabled_collisions,
                                        custom_limits=get_custom_limits(robot))
        attach_pose = multiply(pose.value, invert(grasp.attach))
        approach_pose = multiply(attach_pose, (approach_vector, unit_quat()))
        # approach_pose = multiply(pose.value, invert(grasp.approach))
        for _ in range(max_attempts):
            if USE_IKFAST:
                attach_conf = sample_tool_ik(robot, attach_pose)
            else:
                set_joint_positions(robot, movable_joints, sample_fn())  # Random seed
                attach_conf = inverse_kinematics(robot, tool_link, attach_pose)
            if (attach_conf is None) or collision_fn(attach_conf):
                continue
            set_joint_positions(robot, movable_joints, attach_conf)
            #if USE_IKFAST:
            #    approach_conf = sample_tool_ik(robot, approach_pose, nearby_conf=attach_conf)
            #else:
            approach_conf = inverse_kinematics(robot, tool_link, approach_pose)
            if (approach_conf is None) or collision_fn(approach_conf):
                continue
            set_joint_positions(robot, movable_joints, approach_conf)
            path = plan_direct_joint_motion(robot, movable_joints, attach_conf,
                                            obstacles=obstacles,
                                            self_collisions=SELF_COLLISIONS,
                                            disabled_collisions=disabled_collisions)
            if path is None: # TODO: retreat
                continue
            #path = [approach_conf, attach_conf]
            attachment = Attachment(robot, tool_link, grasp.attach, body)
            traj = MotionTrajectory(robot, movable_joints, path, attachments=[attachment])
            yield approach_conf, traj
            break
    return gen_fn

